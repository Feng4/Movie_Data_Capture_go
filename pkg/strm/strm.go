package strm

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"movie-data-capture/internal/config"
	"movie-data-capture/internal/scraper"
	"movie-data-capture/pkg/logger"
)

// STRMGenerator 处理STRM文件的生成
type STRMGenerator struct {
	config *config.Config
}

// New 创建一个新的STRM生成器实例
func New(cfg *config.Config) *STRMGenerator {
	return &STRMGenerator{
		config: cfg,
	}
}

// GenerateSTRM 生成STRM文件
func (sg *STRMGenerator) GenerateSTRM(movieData *scraper.MovieData, originalFilePath, outputDir string) error {
	if !sg.config.STRM.Enable {
		return nil // STRM功能未启用
	}

	// 获取STRM文件路径
	strmPath := sg.getSTRMFilePath(movieData, originalFilePath, outputDir)
	
	// 创建目录
	if err := os.MkdirAll(filepath.Dir(strmPath), 0755); err != nil {
		return fmt.Errorf("failed to create STRM directory: %w", err)
	}

	// 确定源路径
	sourcePath, err := sg.getSourcePath(originalFilePath)
	if err != nil {
		return fmt.Errorf("failed to determine source path: %w", err)
	}

	// 生成STRM内容
	content, err := sg.generateSTRMContent(sourcePath, movieData)
	if err != nil {
		return fmt.Errorf("failed to generate STRM content: %w", err)
	}

	// 写入STRM文件
	if err := os.WriteFile(strmPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write STRM file: %w", err)
	}

	logger.Info("Generated STRM file: %s", strmPath)
	return nil
}

// getSTRMFilePath 获取STRM文件路径
func (sg *STRMGenerator) getSTRMFilePath(movieData *scraper.MovieData, originalFilePath, outputDir string) string {
	// 获取原始文件名（不含扩展名）
	baseName := strings.TrimSuffix(filepath.Base(originalFilePath), filepath.Ext(originalFilePath))
	
	// 根据命名规则生成文件名
	fileName := sg.generateFileName(movieData, baseName)
	
	// 添加.strm扩展名
	strmFileName := fileName + ".strm"
	
	return filepath.Join(outputDir, strmFileName)
}

// generateFileName 根据命名规则生成文件名
func (sg *STRMGenerator) generateFileName(movieData *scraper.MovieData, baseName string) string {
	namingRule := sg.config.NameRule.NamingRule
	
	// 替换占位符
	fileName := strings.ReplaceAll(namingRule, "number", movieData.Number)
	fileName = strings.ReplaceAll(fileName, "title", movieData.Title)
	fileName = strings.ReplaceAll(fileName, "actor", movieData.Actor)
	fileName = strings.ReplaceAll(fileName, "year", movieData.Year)
	fileName = strings.ReplaceAll(fileName, "studio", movieData.Studio)
	
	// 如果没有规则匹配，使用基础名称
	if fileName == namingRule {
		fileName = baseName
	}
	
	// 清理文件名中的无效字符
	return sg.cleanFileName(fileName)
}

// cleanFileName 清理文件名中的无效字符
func (sg *STRMGenerator) cleanFileName(fileName string) string {
	// Windows/Linux文件名无效字符
	invalidChars := []string{"<", ">", ":", "\"", "|", "?", "*", "/", "\\"}
	
	for _, char := range invalidChars {
		fileName = strings.ReplaceAll(fileName, char, "_")
	}
	
	// 限制文件名长度
	maxLen := sg.config.NameRule.MaxTitleLen
	if maxLen > 0 && len(fileName) > maxLen {
		fileName = fileName[:maxLen]
	}
	
	return fileName
}

// getSourcePath 获取源路径
func (sg *STRMGenerator) getSourcePath(originalFilePath string) (string, error) {
	switch sg.config.STRM.PathType {
	case "absolute":
		// 绝对路径
		absPath, err := filepath.Abs(originalFilePath)
		if err != nil {
			return "", fmt.Errorf("failed to get absolute path: %w", err)
		}
		return absPath, nil
		
	case "relative":
		// 相对路径（相对于STRM文件）
		return originalFilePath, nil
		
	case "network":
		// 网络路径
		if sg.config.STRM.NetworkBasePath != "" {
			// 替换本地路径为网络路径
			relPath, err := filepath.Rel(sg.config.Common.SourceFolder, originalFilePath)
			if err != nil {
				return "", fmt.Errorf("failed to get relative path: %w", err)
			}
			
			// 转换路径分隔符（Windows网络路径使用反斜杠）
			if sg.config.STRM.UseWindowsPath {
				relPath = strings.ReplaceAll(relPath, "/", "\\")
				return sg.config.STRM.NetworkBasePath + "\\" + relPath, nil
			} else {
				relPath = strings.ReplaceAll(relPath, "\\", "/")
				return sg.config.STRM.NetworkBasePath + "/" + relPath, nil
			}
		}
		return originalFilePath, nil
		
	default:
		return originalFilePath, nil
	}
}

// generateSTRMContent 生成STRM文件内容
func (sg *STRMGenerator) generateSTRMContent(sourcePath string, movieData *scraper.MovieData) (string, error) {
	var content strings.Builder
	
	// 根据模式生成内容
	switch sg.config.STRM.ContentMode {
	case "simple":
		// 简单模式：只包含路径
		content.WriteString(sourcePath)
		
	case "detailed":
		// 详细模式：包含注释和元数据
		content.WriteString("# Generated by Movie Data Capture Go\n")
		content.WriteString(fmt.Sprintf("# Movie: %s (%s)\n", movieData.Title, movieData.Number))
		content.WriteString(fmt.Sprintf("# Actor: %s\n", movieData.Actor))
		content.WriteString(fmt.Sprintf("# Studio: %s\n", movieData.Studio))
		content.WriteString(fmt.Sprintf("# Release: %s\n", movieData.Release))
		content.WriteString("\n")
		content.WriteString(sourcePath)
		
	case "playlist":
		// 播放列表模式：M3U格式
		content.WriteString("#EXTM3U\n")
		content.WriteString(fmt.Sprintf("#EXTINF:-1,%s\n", movieData.Title))
		content.WriteString(sourcePath)
		
	default:
		content.WriteString(sourcePath)
	}
	
	return content.String(), nil
}

// GenerateMultiPartSTRM 为分片文件生成STRM文件
func (sg *STRMGenerator) GenerateMultiPartSTRM(movieData *scraper.MovieData, fragmentFiles []string, outputDir string) error {
	if !sg.config.STRM.Enable {
		return nil
	}

	// 为每个分片生成单独的STRM文件
	if sg.config.STRM.MultiPartMode == "separate" {
		for i, fragFile := range fragmentFiles {
			partMovieData := *movieData // 复制数据
			partMovieData.Number = fmt.Sprintf("%s-Part%d", movieData.Number, i+1)
			
			if err := sg.GenerateSTRM(&partMovieData, fragFile, outputDir); err != nil {
				return fmt.Errorf("failed to generate STRM for part %d: %w", i+1, err)
			}
		}
		return nil
	}

	// 生成单个包含所有分片的STRM文件
	if sg.config.STRM.MultiPartMode == "combined" {
		strmPath := sg.getSTRMFilePath(movieData, fragmentFiles[0], outputDir)
		
		var content strings.Builder
		
		if sg.config.STRM.ContentMode == "playlist" {
			content.WriteString("#EXTM3U\n")
			for i, fragFile := range fragmentFiles {
				content.WriteString(fmt.Sprintf("#EXTINF:-1,%s Part %d\n", movieData.Title, i+1))
				
				sourcePath, err := sg.getSourcePath(fragFile)
				if err != nil {
					return fmt.Errorf("failed to get source path for fragment: %w", err)
				}
				content.WriteString(sourcePath + "\n")
			}
		} else {
			// 简单模式：列出所有文件
			content.WriteString("# Multi-part movie\n")
			for _, fragFile := range fragmentFiles {
				sourcePath, err := sg.getSourcePath(fragFile)
				if err != nil {
					return fmt.Errorf("failed to get source path for fragment: %w", err)
				}
				content.WriteString(sourcePath + "\n")
			}
		}

		// 创建目录并写入文件
		if err := os.MkdirAll(filepath.Dir(strmPath), 0755); err != nil {
			return fmt.Errorf("failed to create STRM directory: %w", err)
		}

		if err := os.WriteFile(strmPath, []byte(content.String()), 0644); err != nil {
			return fmt.Errorf("failed to write combined STRM file: %w", err)
		}

		logger.Info("Generated combined STRM file: %s", strmPath)
	}

	return nil
}

// ValidateSTRM 验证STRM文件是否有效
func (sg *STRMGenerator) ValidateSTRM(strmPath string) error {
	if !sg.config.STRM.ValidateFiles {
		return nil
	}

	content, err := os.ReadFile(strmPath)
	if err != nil {
		return fmt.Errorf("failed to read STRM file: %w", err)
	}

	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// 验证路径是否存在（仅对本地路径）
		if !strings.HasPrefix(line, "http://") && !strings.HasPrefix(line, "https://") {
			if _, err := os.Stat(line); err != nil {
				logger.Warn("STRM file references non-existent path: %s", line)
				if sg.config.STRM.StrictValidation {
					return fmt.Errorf("STRM file references invalid path: %s", line)
				}
			}
		}
	}

	return nil
}